"""
Deployment configuration management.

Auto-detects project dependencies and generates deployment configurations.
"""

from pathlib import Path
from typing import Dict, List, Set, Optional
from dataclasses import dataclass, field
import re
import json


@dataclass
class DeployConfig:
    """
    Deployment configuration for a project.

    Automatically detects which pheno-sdk packages are used and
    provides deployment-ready configuration.
    """

    project_root: Path
    pheno_packages: Set[str] = field(default_factory=set)
    external_deps: Set[str] = field(default_factory=set)
    python_version: str = "3.10"
    entry_point: Optional[str] = None

    def __post_init__(self):
        """Auto-detect configuration from project."""
        self.project_root = Path(self.project_root).resolve()
        self._detect_dependencies()
        self._detect_python_version()
        self._detect_entry_point()

    def _detect_dependencies(self) -> None:
        """Detect project dependencies from requirements.txt."""
        req_file = self.project_root / "requirements.txt"

        if not req_file.exists():
            return

        content = req_file.read_text()

        for line in content.splitlines():
            line = line.strip()

            # Skip comments and empty lines
            if not line or line.startswith("#"):
                continue

            # Detect pheno-sdk packages
            if line.startswith("-e") and "pheno-sdk" in line:
                # Extract package name from path
                # e.g., "-e ../pheno-sdk/adapter-kit" -> "adapter-kit"
                match = re.search(r"pheno-sdk/([^/\s]+)", line)
                if match:
                    self.pheno_packages.add(match.group(1))
            else:
                # External dependency
                # Extract package name (before any version specifier)
                pkg_name = re.split(r"[=<>!]", line)[0].strip()
                if pkg_name and not pkg_name.startswith("-"):
                    self.external_deps.add(pkg_name)

    def _detect_python_version(self) -> None:
        """Detect Python version from pyproject.toml or runtime.txt."""
        # Try pyproject.toml
        pyproject = self.project_root / "pyproject.toml"
        if pyproject.exists():
            content = pyproject.read_text()
            match = re.search(r'requires-python\s*=\s*">=(\d+\.\d+)"', content)
            if match:
                self.python_version = match.group(1)
                return

        # Try runtime.txt (Vercel/Heroku format)
        runtime = self.project_root / "runtime.txt"
        if runtime.exists():
            content = runtime.read_text().strip()
            match = re.search(r"python-(\d+\.\d+)", content)
            if match:
                self.python_version = match.group(1)
                return

    def _detect_entry_point(self) -> None:
        """Detect main entry point for the application."""
        # Common entry points
        candidates = [
            "server.py",
            "main.py",
            "app.py",
            "api.py",
            "__main__.py",
            "src/server.py",
            "src/main.py",
        ]

        for candidate in candidates:
            entry = self.project_root / candidate
            if entry.exists():
                self.entry_point = candidate
                return

    def to_vercel_config(self) -> Dict:
        """
        Generate Vercel deployment configuration.

        Returns:
            Dict suitable for vercel.json
        """
        config = {
            "version": 2,
            "builds": [
                {
                    "src": self.entry_point or "server.py",
                    "use": "@vercel/python",
                    "config": {
                        "maxLambdaSize": "50mb",
                    },
                }
            ],
            "routes": [
                {
                    "src": "/(.*)",
                    "dest": self.entry_point or "server.py",
                }
            ],
            "env": {
                "PYTHONPATH": "pheno_vendor",
            },
        }

        return config

    def to_docker_config(self) -> str:
        """
        Generate Dockerfile.

        Returns:
            Dockerfile content as string
        """
        dockerfile = f"""# Generated by pheno-vendor
FROM python:{self.python_version}-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    build-essential \\
    && rm -rf /var/lib/apt/lists/*

# Copy vendored packages
COPY pheno_vendor/ /app/pheno_vendor/
COPY sitecustomize.py /app/

# Copy requirements and install
COPY requirements-prod.txt /app/
RUN pip install --no-cache-dir -r requirements-prod.txt

# Copy application
COPY . /app/

# Set Python path to include vendored packages
ENV PYTHONPATH=/app/pheno_vendor

# Run application
CMD ["python", "{self.entry_point or 'server.py'}"]
"""
        return dockerfile

    def to_lambda_config(self) -> Dict:
        """
        Generate AWS Lambda configuration.

        Returns:
            Dict suitable for serverless.yml or SAM template
        """
        config = {
            "runtime": f"python{self.python_version}",
            "handler": (self.entry_point or "server").replace(".py", ".handler"),
            "timeout": 30,
            "memorySize": 1024,
            "environment": {
                "PYTHONPATH": "/var/task/pheno_vendor",
            },
            "layers": [
                # Could add custom layer for vendored packages
            ],
        }

        return config

    def to_railway_config(self) -> Dict:
        """
        Generate Railway deployment configuration.

        Returns:
            Dict suitable for railway.json
        """
        config = {
            "build": {
                "builder": "nixpacks",
                "buildCommand": "pip install -r requirements-prod.txt",
            },
            "deploy": {
                "startCommand": f"python {self.entry_point or 'server.py'}",
                "restartPolicyType": "ON_FAILURE",
            },
        }

        return config

    def generate_build_script(self, platform: str = "vercel") -> str:
        """
        Generate build script for platform.

        Args:
            platform: Target platform (vercel, docker, lambda, railway)

        Returns:
            Shell script content
        """
        script = """#!/bin/bash
set -e

echo "Building for {platform}..."

# Vendor pheno-sdk packages
echo "Vendoring pheno-sdk packages..."
python -m deploy_kit.vendor vendor

# Install production dependencies
echo "Installing dependencies..."
pip install -r requirements-prod.txt

# Run tests (optional)
if [ -d "tests" ]; then
    echo "Running tests..."
    pytest tests/ || true
fi

echo "Build complete!"
""".format(platform=platform)

        return script

    def save_configs(self, output_dir: Optional[Path] = None) -> List[Path]:
        """
        Save all platform configurations to files.

        Args:
            output_dir: Directory to save configs (default: project root)

        Returns:
            List of created file paths
        """
        output_dir = Path(output_dir or self.project_root)
        created_files = []

        # Vercel config
        vercel_config = output_dir / "vercel.json"
        vercel_config.write_text(json.dumps(self.to_vercel_config(), indent=2))
        created_files.append(vercel_config)

        # Dockerfile
        dockerfile = output_dir / "Dockerfile"
        dockerfile.write_text(self.to_docker_config())
        created_files.append(dockerfile)

        # Railway config
        railway_config = output_dir / "railway.json"
        railway_config.write_text(json.dumps(self.to_railway_config(), indent=2))
        created_files.append(railway_config)

        # Build script
        build_script = output_dir / "build.sh"
        build_script.write_text(self.generate_build_script())
        build_script.chmod(0o755)
        created_files.append(build_script)

        return created_files


class PackageDetector:
    """
    Detect which pheno-sdk packages are actually used in a project.

    Uses multiple strategies:
    1. Parse requirements.txt
    2. Scan Python imports
    3. Check for common usage patterns
    """

    def __init__(self, project_root: Path):
        self.project_root = Path(project_root).resolve()

    def detect_from_requirements(self) -> Set[str]:
        """Detect packages from requirements.txt."""
        packages = set()
        req_file = self.project_root / "requirements.txt"

        if not req_file.exists():
            return packages

        content = req_file.read_text()

        for line in content.splitlines():
            if "pheno-sdk" in line:
                match = re.search(r"pheno-sdk/([^/\s]+)", line)
                if match:
                    packages.add(match.group(1))

        return packages

    def detect_from_imports(self) -> Set[str]:
        """Detect packages by scanning Python imports."""
        packages = set()

        # Package name mappings
        module_to_package = {
            "pydevkit": "pydevkit",
            "adapter_kit": "adapter-kit",
            "stream_kit": "stream-kit",
            "storage_kit": "storage-kit",
            "db_kit": "db-kit",
            "mcp_qa": "mcp-QA",
            "process_monitor": "process-monitor-sdk",
            "tui_kit": "tui-kit",
            "workflow_kit": "workflow-kit",
            "event_kit": "event-kit",
            "deploy_kit": "deploy-kit",
            "observability_kit": "observability-kit",
            "cli_builder": "cli-builder-kit",
            "filewatch_kit": "filewatch-kit",
            "mcp_sdk_kit": "mcp-sdk-kit",
            "kinfra": "KInfra",
        }

        # Scan Python files
        for py_file in self.project_root.rglob("*.py"):
            # Skip vendor and venv directories
            if "vendor" in str(py_file) or ".venv" in str(py_file):
                continue

            try:
                content = py_file.read_text()

                for module_name, package_name in module_to_package.items():
                    # Check for imports
                    patterns = [
                        f"import {module_name}",
                        f"from {module_name}",
                    ]

                    if any(pattern in content for pattern in patterns):
                        packages.add(package_name)

            except Exception:
                pass

        return packages

    def detect_all(self) -> Set[str]:
        """Use all detection strategies."""
        packages = set()
        packages.update(self.detect_from_requirements())
        packages.update(self.detect_from_imports())
        return packages
