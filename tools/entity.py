"""Unified entity CRUD operations tool."""

from __future__ import annotations

import re
import asyncio
from typing import Dict, Any, Optional, List, Literal, Union
from datetime import datetime, timezone

try:
    from .base import ToolBase
except ImportError:
    from tools.base import ToolBase


slug_pattern = re.compile(r"[^a-z0-9]+")


def _slugify(value: str) -> str:
    """Convert a string to a URL-friendly slug."""
    slug = slug_pattern.sub("-", value.strip().lower()).strip("-")
    return slug or "document"


class EntityManager(ToolBase):
    """Manages CRUD operations for all entity types."""
    
    def __init__(self):
        super().__init__()
    
    def _get_entity_schema(self, entity_type: str) -> Dict[str, Any]:
        """Get schema information for entity type."""
        schemas = {
            "organization": {
                "required_fields": ["name", "slug"],
                "auto_fields": ["id", "created_at", "updated_at"],
                "default_values": {"is_deleted": False, "type": "team"},
                "relationships": ["members", "projects", "invitations"]
            },
            "project": {
                "required_fields": ["name", "organization_id"],
                "auto_fields": ["id", "created_at", "updated_at"],
                "default_values": {"is_deleted": False},
                "relationships": ["members", "documents", "organization"],
                "auto_slug": True
            },
            "document": {
                "required_fields": ["name", "project_id"],
                "auto_fields": ["id", "created_at", "updated_at"],
                "default_values": {"is_deleted": False},
                "relationships": ["blocks", "requirements", "project"]
            },
            "requirement": {
                "required_fields": ["name", "document_id", "block_id"],
                "auto_fields": ["id", "created_at", "updated_at", "version", "external_id"],
                "default_values": {"is_deleted": False, "status": "active", "properties": {}, "priority": "low", "type": "component"},
                "relationships": ["document", "tests", "trace_links"]
            },
            "test": {
                "required_fields": ["title", "project_id"],
                "auto_fields": ["id", "created_at", "updated_at"],
                "default_values": {"is_active": True, "status": "pending", "priority": "medium"},
                "relationships": ["requirements", "project"]
            }
        }
        return schemas.get(entity_type.lower(), {})
    
    def _apply_defaults(self, entity_type: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Apply default values and auto-generated fields."""
        schema = self._get_entity_schema(entity_type)
        result = data.copy()
        
        # Apply defaults
        for field, value in schema.get("default_values", {}).items():
            if field not in result:
                result[field] = value
        
        # Apply auto fields
        user_id = self._get_user_id()
        if "created_by" not in result and user_id:
            result["created_by"] = user_id
        if "updated_by" not in result and user_id:
            result["updated_by"] = user_id

        # Special handling for projects - set owned_by
        if entity_type.lower() == "project" and "owned_by" not in result and user_id:
            result["owned_by"] = user_id
        
        # Generate external_id for requirements
        if entity_type.lower() == "requirement" and "external_id" not in result:
            # This would be generated by the database trigger normally
            result["external_id"] = f"REQ-{int(datetime.now().timestamp())}"

        # Auto-generate slug for entities that need it
        if schema.get("auto_slug") and not result.get("slug") and result.get("name"):
            result["slug"] = _slugify(result["name"])

        if entity_type.lower() == "document":
            if not result.get("slug") and result.get("name"):
                result["slug"] = _slugify(result["name"])
        
        return result
    
    def _validate_required_fields(self, entity_type: str, data: Dict[str, Any]) -> None:
        """Validate that required fields are present."""
        schema = self._get_entity_schema(entity_type)
        required = schema.get("required_fields", [])
        
        missing = [field for field in required if field not in data]
        if missing:
            raise ValueError(f"Missing required fields for {entity_type}: {missing}")
    
    async def _resolve_smart_defaults(self, entity_type: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Resolve smart defaults like 'auto' for organization_id."""
        result = data.copy()
        user_id = self._get_user_id()
        
        # Import workspace manager to get defaults
        from .workspace import _workspace_manager
        defaults = await _workspace_manager.get_smart_defaults(user_id)
        
        # Apply smart defaults
        if result.get("organization_id") == "auto":
            if defaults["organization_id"]:
                result["organization_id"] = defaults["organization_id"]
            else:
                raise ValueError("No active organization found for 'auto' resolution")
        
        if result.get("project_id") == "auto":
            if defaults["project_id"]:
                result["project_id"] = defaults["project_id"]
            else:
                raise ValueError("No active project found for 'auto' resolution")
        
        if result.get("document_id") == "auto":
            if defaults["document_id"]:
                result["document_id"] = defaults["document_id"]
            else:
                raise ValueError("No active document found for 'auto' resolution")
        
        return result
    
    async def create_entity(
        self,
        entity_type: str,
        data: Dict[str, Any],
        include_relations: bool = False
    ) -> Dict[str, Any]:
        """Create a new entity."""
        # Resolve smart defaults
        data = await self._resolve_smart_defaults(entity_type, data)

        # Apply defaults and validate
        data = self._apply_defaults(entity_type, data)
        self._validate_required_fields(entity_type, data)

        # Get table name
        table = self._resolve_entity_table(entity_type)

        # Create entity
        result = await self._db_insert(table, data, returning="*")

        # Skip relationship inclusion for create to avoid Supabase client issues
        # Relationships can be fetched separately with read operation if needed

        # Generate embedding asynchronously for searchable entities
        # This runs in background and won't block the response
        if entity_type in ["organization", "project", "document", "requirement"]:
            asyncio.create_task(self._generate_embedding_async(entity_type, result))

        return result

    async def _generate_embedding_async(self, entity_type: str, entity_data: Dict[str, Any]):
        """Generate embedding for entity in background.

        This method runs asynchronously and won't block entity creation.
        Errors are logged but don't fail the entity creation operation.
        """
        try:
            from services.progressive_embedding import ProgressiveEmbeddingService
            from services.embedding_factory import get_embedding_service

            # Initialize services
            embedding_service = get_embedding_service()
            progressive_service = ProgressiveEmbeddingService(self.supabase, embedding_service)

            # Get table name for this entity type
            table_name = progressive_service._get_table_name(entity_type)

            # Generate embedding
            await progressive_service.generate_embedding_on_demand(
                table_name,
                entity_data["id"],
                entity_data
            )

        except Exception as e:
            # Log error but don't fail entity creation
            # In production, this should use proper logging
            print(f"Warning: Failed to generate embedding for {entity_type} {entity_data.get('id')}: {e}")
    
    async def read_entity(
        self,
        entity_type: str,
        entity_id: str,
        include_relations: bool = False
    ) -> Optional[Dict[str, Any]]:
        """Read an entity by ID."""
        table = self._resolve_entity_table(entity_type)
        
        result = await self._db_get_single(
            table,
            filters={"id": entity_id}
        )
        
        if result and include_relations:
            result = await self._include_relationships(entity_type, result)
        
        return result
    
    async def update_entity(
        self,
        entity_type: str,
        entity_id: str,
        data: Dict[str, Any],
        include_relations: bool = False
    ) -> Dict[str, Any]:
        """Update an entity."""
        import logging
        logger = logging.getLogger(__name__)

        table = self._resolve_entity_table(entity_type)

        # Add updated timestamp and user
        update_data = data.copy()
        update_data["updated_at"] = datetime.now(timezone.utc).isoformat()

        # Always set updated_by (required field)
        user_id = self._get_user_id()
        print(f"üîç UPDATE: user_id from context: '{user_id}', full context: {self._user_context}")
        logger.info(f"üîç UPDATE: user_id from context: '{user_id}', full context: {self._user_context}")

        if not user_id:
            # Fallback: Query existing record to get created_by
            print(f"‚ö†Ô∏è UPDATE: No user_id in context, using fallback query")
            logger.info(f"‚ö†Ô∏è UPDATE: No user_id in context, using fallback query")
            try:
                # Use direct Supabase client to bypass RLS temporarily
                result = self.supabase.table(table).select("created_by, updated_by").eq("id", entity_id).execute()
                print(f"üîç UPDATE: Fallback query result: {result.data if result else 'None'}")
                logger.info(f"üîç UPDATE: Fallback query result: {result.data if result else 'None'}")
                if result.data and len(result.data) > 0:
                    user_id = result.data[0].get("created_by") or result.data[0].get("updated_by")
                    print(f"‚úÖ UPDATE: Got user_id from fallback: {user_id}")
                    logger.info(f"‚úÖ UPDATE: Got user_id from fallback: {user_id}")
            except Exception as e:
                print(f"‚ùå UPDATE: Fallback query failed: {e}")
                logger.error(f"‚ùå UPDATE: Fallback query failed: {e}")
                pass

        # Ensure updated_by is always set
        if not user_id:
            print(f"‚ùå UPDATE: Could not determine user_id. Context: {self._user_context}")
            logger.error(f"‚ùå UPDATE: Could not determine user_id. Context: {self._user_context}")
            raise ValueError(f"Could not determine user_id for update operation. Context: {self._user_context}")

        update_data["updated_by"] = user_id
        print(f"‚úÖ UPDATE: Set updated_by to: {user_id}")
        logger.info(f"‚úÖ UPDATE: Set updated_by to: {user_id}")

        result = await self._db_update(
            table,
            update_data,
            filters={"id": entity_id},
            returning="*"
        )

        if include_relations and isinstance(result, dict):
            result = await self._include_relationships(entity_type, result)

        return result
    
    async def delete_entity(
        self,
        entity_type: str,
        entity_id: str,
        soft_delete: bool = True
    ) -> bool:
        """Delete an entity (soft delete by default)."""
        table = self._resolve_entity_table(entity_type)
        
        if soft_delete:
            # Soft delete
            delete_data = {
                "is_deleted": True,
                "deleted_at": datetime.now(timezone.utc).isoformat(),
                "updated_at": datetime.now(timezone.utc).isoformat()
            }

            # Get user_id with fallback
            user_id = self._get_user_id()
            if not user_id:
                # Fallback: Query existing record to get created_by
                try:
                    result = self.supabase.table(table).select("created_by, updated_by").eq("id", entity_id).execute()
                    if result.data and len(result.data) > 0:
                        user_id = result.data[0].get("created_by") or result.data[0].get("updated_by")
                except Exception:
                    pass

            # Ensure user fields are set
            if not user_id:
                raise ValueError(f"Could not determine user_id for delete operation. Context: {self._user_context}")

            delete_data["deleted_by"] = user_id
            delete_data["updated_by"] = user_id
            
            result = await self._db_update(
                table,
                delete_data,
                filters={"id": entity_id}
            )
            return bool(result)
        else:
            # Hard delete
            count = await self._db_delete(table, filters={"id": entity_id})
            return count > 0
    
    async def search_entities(
        self,
        entity_type: str,
        filters: Optional[Dict[str, Any]] = None,
        search_term: Optional[str] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        order_by: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """Search for entities with filters."""
        table = self._resolve_entity_table(entity_type)
        
        # Build query filters
        query_filters = filters.copy() if filters else {}
        
        # Add default filters
        if "is_deleted" not in query_filters:
            query_filters["is_deleted"] = False
        
        # Handle search term
        if search_term:
            # This is simplified - in practice you'd use full-text search
            query_filters["name"] = {"ilike": f"%{search_term}%"}
        
        # Set default ordering
        if not order_by:
            order_by = "created_at:desc"
        
        return await self._db_query(
            table,
            filters=query_filters,
            limit=limit,
            offset=offset,
            order_by=order_by
        )
    
    async def list_entities(
        self,
        entity_type: str,
        parent_type: Optional[str] = None,
        parent_id: Optional[str] = None,
        limit: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """List entities, optionally filtered by parent."""
        filters = {"is_deleted": False}
        
        # Add parent filter
        if parent_type and parent_id:
            parent_key = f"{parent_type}_id"
            filters[parent_key] = parent_id
        
        return await self.search_entities(
            entity_type,
            filters=filters,
            limit=limit
        )
    
    async def _include_relationships(
        self,
        entity_type: str,
        entity: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Include related entities in the response."""
        result = entity.copy()
        entity_id = entity["id"]
        
        if entity_type.lower() == "organization":
            # Include member count and recent projects
            member_count = await self._db_count(
                "organization_members",
                filters={"organization_id": entity_id, "status": "active"}
            )
            result["member_count"] = member_count
            
            recent_projects = await self._db_query(
                "projects",
                filters={"organization_id": entity_id, "is_deleted": False},
                limit=5,
                order_by="updated_at:desc"
            )
            result["recent_projects"] = recent_projects
        
        elif entity_type.lower() == "project":
            # Include document count and members
            doc_count = await self._db_count(
                "documents", 
                filters={"project_id": entity_id, "is_deleted": False}
            )
            result["document_count"] = doc_count
            
            members = await self._db_query(
                "project_members",
                select="*, profiles(*)",
                filters={"project_id": entity_id, "status": "active"}
            )
            result["members"] = members
        
        elif entity_type.lower() == "document":
            # Include requirement count and blocks
            req_count = await self._db_count(
                "requirements",
                filters={"document_id": entity_id, "is_deleted": False}
            )
            result["requirement_count"] = req_count
            
            blocks = await self._db_query(
                "blocks",
                filters={"document_id": entity_id, "is_deleted": False},
                order_by="position"
            )
            result["blocks"] = blocks
        
        return result


# Global manager instance
_entity_manager = EntityManager()


async def entity_operation(
    auth_token: str,
    operation: Literal["create", "read", "update", "delete", "search", "list"],
    entity_type: str,
    data: Optional[Dict[str, Any]] = None,
    filters: Optional[Dict[str, Any]] = None,
    entity_id: Optional[str] = None,
    include_relations: bool = False,
    batch: Optional[List[Dict[str, Any]]] = None,
    search_term: Optional[str] = None,
    parent_type: Optional[str] = None,
    parent_id: Optional[str] = None,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    order_by: Optional[str] = None,
    soft_delete: bool = True,
    format_type: str = "detailed"
) -> Dict[str, Any]:
    """Unified CRUD operations for any entity type.
    
    Args:
        auth_token: Authentication token
        operation: CRUD operation to perform
        entity_type: Type of entity (organization, project, document, etc.)
        data: Data for create/update operations
        filters: Filter conditions for search
        entity_id: ID for read/update/delete operations
        include_relations: Whether to include related entities
        batch: List of entities for batch operations
        search_term: Text search term
        parent_type: Parent entity type for filtering
        parent_id: Parent entity ID for filtering
        limit: Maximum results to return
        offset: Offset for pagination
        order_by: Sort order (e.g., "name:asc", "created_at:desc")
        soft_delete: Use soft delete for delete operations
        format_type: Result format (detailed, summary, raw)
    
    Returns:
        Dict containing operation result
    """
    try:
        # Validate authentication
        await _entity_manager._validate_auth(auth_token)
        
        if operation == "create":
            if not data:
                raise ValueError("data is required for create operation")
            
            if batch:
                # Batch create
                results = []
                for item in batch:
                    result = await _entity_manager.create_entity(
                        entity_type, item, include_relations
                    )
                    results.append(result)
                return _entity_manager._format_result(results, format_type)
            else:
                # Single create
                result = await _entity_manager.create_entity(
                    entity_type, data, include_relations
                )
                return _entity_manager._format_result(result, format_type)
        
        elif operation == "read":
            if not entity_id:
                raise ValueError("entity_id is required for read operation")
            
            result = await _entity_manager.read_entity(
                entity_type, entity_id, include_relations
            )
            if result is None:
                return {"success": False, "error": "Entity not found"}
            
            return _entity_manager._format_result(result, format_type)
        
        elif operation == "update":
            if not entity_id or not data:
                raise ValueError("entity_id and data are required for update operation")
            
            result = await _entity_manager.update_entity(
                entity_type, entity_id, data, include_relations
            )
            return _entity_manager._format_result(result, format_type)
        
        elif operation == "delete":
            if not entity_id:
                raise ValueError("entity_id is required for delete operation")
            
            success = await _entity_manager.delete_entity(
                entity_type, entity_id, soft_delete
            )
            return {
                "success": success,
                "entity_id": entity_id,
                "entity_type": entity_type,
                "soft_delete": soft_delete
            }
        
        elif operation == "search":
            result = await _entity_manager.search_entities(
                entity_type, filters, search_term, limit, offset, order_by
            )
            return _entity_manager._format_result(result, format_type)
        
        elif operation == "list":
            result = await _entity_manager.list_entities(
                entity_type, parent_type, parent_id, limit
            )
            return _entity_manager._format_result(result, format_type)
        
        else:
            raise ValueError(f"Unknown operation: {operation}")
    
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "operation": operation,
            "entity_type": entity_type
        }
